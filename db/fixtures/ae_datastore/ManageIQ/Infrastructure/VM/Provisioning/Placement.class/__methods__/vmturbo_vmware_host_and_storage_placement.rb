#
# Description: This method connects to a VMTurbo Operations Manager to request Host and 
# Datastore placement recommendations for a VM.  It requires VMTurbo credentials, 
# which are currently hard-coded in this method as global variables.
#
def root_folder(host, data_center)
  host.ext_management_system.ems_folders.detect { |f| f.folder_path == "Datacenters/#{data_center}/vm" }
end

def set_folder(prov, host, vm)
  host_dc = host.ems_cluster.v_parent_datacenter
  $evm.log("info", "selected datacenter [#{host_dc}]")
  matching_folder = vm.v_owning_blue_folder_path.sub("/#{vm.v_owning_datacenter}/", "/#{host_dc}/")
  folder = prov.eligible_folders.detect { |f| f.folder_path == matching_folder }
  folder ||= root_folder(host, host_dc)
  if folder
    $evm.log("info", "selected folder [#{folder.folder_path}]")
    # prov.set_folder is not being used intentionally since it currently does not support root vm folders
    prov.set_option(:placement_folder_name, [folder.id, folder.name])
  end
end
$evm.log("info", "Args:    #{MIQ_ARGS.inspect}")

# Get variables
prov = $evm.root["miq_provision"]
vm = prov.vm_template
raise "VM template not specified" if vm.nil?
ems = vm.ext_management_system
raise "EMS not found for VM template [#{vm.name}]" if ems.nil?

#############################
# VMTurbo additions - start
#############################
require 'nokogiri'
require "net/http"
require "uri"

# Global Constants
LOG_PREFIX = "*** VMTurbo *** "

# VMTurbo server credentials (TODO: Put these in a conf file and read them in at run time.)
$vmt_host = "10.10.172.84"
$vmt_username = "administrator"
$vmt_password = "administrator"

##
# VMTScheduler Class
#
# Retrieves Host & Storage placement recommendations for a new VM from a VMTurbo Server.
# The VMTurbo Server location and credentials must be passed to an instance of this class.
#
# == Attributes
#
# * +vmt_host+     - IP address or Host name of the VMTurbo server
# * +vmt_username+ - a VMTurbo username with admin role
# * +vmt_password+ - the password associated with the VMTurbo username
#
class VMTurboScheduler

  ##
  # Constants
  #
  # VMTurbo Rest API resources
  VMT_API = "/vmturbo/api/"
  VMT_RESOURCE_RESERVATIONS = "reservations"
  VMT_RESOURCE_TEMPLATES = "templates"

  # poll for placement results every 2 seconds for up to 5 minutes
  VMT_SECONDS_BETWEEN_POLLS = 2
  VMT_NUM_POLLS = 150

  ##
  # Utility methods
  #
  def log(level, message)
    $evm.log(level, LOG_PREFIX + message)
  end

  ##
  # Intializes the VMTurbo server credentials.
  #
  # Params:
  # +vmt_host+     - IP address or Host name of the VMTurbo server
  # +vmt_username+ - a VMTurbo username with admin role
  # +vmt_password+ - the password associated with the VMTurbo username
  #
  def initialize(vmt_host, vmt_username, vmt_password)
    @vmt_host = vmt_host
    @vmt_username = vmt_username
    @vmt_password = vmt_password
  end

  ##
  # Accesses a VMTurbo Rest resource (with Get, Post or Delete) and returns the 
  # received Net::HTTPResponse object.
  #
  #--
  # TODO: Handle SSL, Host Port and possibly add special check for authentication errors.
  #
  def api_call(resource, request, operation_type_string)
    http = Net::HTTP.new(@vmt_host)
    log("debug", "#{operation_type_string} VMTurbo resource: " + VMT_API + resource)
    request.basic_auth(@vmt_username, @vmt_password)
    resp = http.request(request)
    if (! resp.is_a? Net::HTTPSuccess)
      raise "Error from VMTurbo server: #{resp.class.name}, #{resp.code}, #{resp.message}"
    end
    log("debug", "... VMTurbo response received: #{resp.class.name}, #{resp.code}, #{resp.body}")
    return resp
  end

  ##
  # Retrieves a VMTurbo resource using Rest API and returns a Nokogiri::HTML::Document 
  # object containing the response body.
  #
  def api_get(resource)
    request = Net::HTTP::Get.new(VMT_API + resource)
    response = api_call(resource, request, "Getting")
    doc = Nokogiri::XML(response.body)   
    return doc
  end

  ##
  # Deletes a VMTurbo resource and returns the response body.
  #
  def api_delete(resource)
    request = Net::HTTP::Delete.new(VMT_API + resource)
    response = api_call(resource, request, "Deleting")
    return response.body
  end

  ##
  # Posts data to a VMTurbo resource and returns the response body.
  #
  def api_post(resource, request_data)
    request = Net::HTTP::Post.new(VMT_API + resource)
    request.set_form_data(request_data)
    response = api_call(resource, request, "Posting")
    return response.body
  end
  
  ##
  # Requests a VMTurbo reservation and returns the reservation ID generated by VMTurbo.
  #
  # Params:
  # +template_uuid+           - the Virtual Machine Profile Uuid (= OpenStack Flavor)
  # +deployment_profile_uuid+ - the Service Catalog Item Uuid (= OpenStack Image)
  #
  #--
  # TODO: Handle VM Anti/Affinity groups
  #
  def request_placement(reservationName, vmPrefix, template_uuid, deployment_profile_uuid, 
                        vmCount)
    log("info", "Creating reservation: " + 
        "vmPrefix=" + vmPrefix + ", " +
        "template_uuid=" + template_uuid + ", " +
        "deployment_profile_uuid=" + deployment_profile_uuid + ", " +
        "count=" + vmCount.to_s)
    requests_data_dict = { 
      "vmPrefix" => vmPrefix, 
      "reservationName" => reservationName,
      "templateName" => template_uuid,
      "deploymentProfile" => deployment_profile_uuid,
      "count" => vmCount.to_s
    }
    reservation_uuid = api_post("reservations", requests_data_dict)
    reservation_uuid.strip!
    raise "Reservation not generated by VMTurbo for #{template_uuid}/#{vmPrefix}" if reservation_uuid == ""
    log("debug", "... Reservation created: " + reservation_uuid)
    return reservation_uuid
  end

  ##
  # Returns the current status of a placement request.
  #
  def get_placement_status(reservation_uuid)
    log("debug", "Getting status of reservation: |" + reservation_uuid + "|")
    doc = api_get VMT_RESOURCE_RESERVATIONS

    reservation_xpath = "//TopologyElement[@creationClassName='Reservation'][@uuid='#{reservation_uuid}']"
    status = ''
    nodes = doc.xpath(reservation_xpath)
    raise "Reservation not found with uuid #{reservation_uuid}" if (nodes.size < 1)
    nodes.each do |node|
      log("debug", "... Got status for Reservation uuid: " + node["uuid"] + ", status: " + node["status"])
      status = node['status']
    end
    return status
  end

  ##
  # Returns the resources selected by VMTurbo for the placement request.
  #
  def get_placement_resources(reservation_uuid)
    log("debug", "Getting resources for reservation: " + reservation_uuid)
    doc = api_get VMT_RESOURCE_RESERVATIONS + '/' + reservation_uuid

    resources_xpath = "//ActionItem"
    host = ''
    datastore = ''
    nodes = doc.xpath(resources_xpath)
    raise "Resources not found for reservation with uuid #{reservation_uuid}" if (nodes.size < 1)
    nodes.each do |node|
      log("debug", "... Got resources for Reservation name: " + node["name"] + ", host: " + node["host"] + ", datastore: " + node["datastore"])
      host = node["host"]
      datastore = node["datastore"]
    end
    return host, datastore		
  end
  
  ##
  # Deletes the reservation associated with a placement request.
  #
  def delete_placement(reservation_uuid)
    log("debug", "Deleting reservation: " + reservation_uuid)
    response = api_delete("reservations/" + reservation_uuid)
    response.strip!
    log("debug", "... Delete request for reservation " + reservation_uuid + " returned: " + response)
    return response
  end
  
  ##
  # Returns the VMTurbo uuids of the template and deployment profiles corresponding to a template name.
  #
  #--
  # TODO: Implement xpath "ends-with" and use with template name
  #
  def get_template_uuid_and_deployment_profile_uuid(template_name)
    log("debug", "Getting template uuid and deployment profile uuid for " + template_name)
    doc = api_get(VMT_RESOURCE_TEMPLATES)
    
    template_xpath = "//TopologyElement[@creationClassName='VirtualMachineProfile'][contains(@displayName,'::TMP-#{template_name}')]"
    template_uuid = ''
    deployment_profile_uuid = ''
    nodes = doc.xpath(template_xpath)
    raise "Template not found with name  #{template_name}" if (nodes.size < 1)
    nodes.each do |node|
      log("debug", "... Got template uuid " + node["uuid"] + " and deployment profile uuid " + node["services"])
      template_uuid = node["uuid"]
      deployment_profile_uuid = node["services"]
    end
    return template_uuid, deployment_profile_uuid
  end
  
  ##
  # Waits for the VMTurbo placement request to complete and returns the recommended resource placements.
  #
  def poll_for_status(reservation_uuid)
    statusRes = ''
    host = ''
    datastore = ''
    count = 0	
    
    log("debug", "Waiting up to #{(VMT_NUM_POLLS*VMT_SECONDS_BETWEEN_POLLS).to_s} seconds for reservation #{reservation_uuid} request to complete: ")
    # wait for the placement request to complete
    while (statusRes == "" or statusRes == "LOADING" or statusRes == "UNFULFILLED")
      count += 1
      if (count > VMT_NUM_POLLS)
        log("warn", "Placement request did not complete in " + (VMT_NUM_POLLS*VMT_SECONDS_BETWEEN_POLLS).to_s + " seconds")
        break
      end
      statusRes = get_placement_status(reservation_uuid)
      log("debug", "Count: " + count.to_s + ", status: " + statusRes + ", res: " + reservation_uuid)
      sleep(VMT_SECONDS_BETWEEN_POLLS)
    end
    
    # get the placement results
    if (statusRes == "PLACEMENT_SUCCEEDED")
      log("debug", "Placement request " + reservation_uuid + " succeeded")
      host, datastore = get_placement_resources(reservation_uuid)
    elsif (statusRes == "PLACEMENT_FAILED")
      log("warn", "Placement request " + reservation_uuid + " could not be satisfied with existing resources")
    else
      log("warn", "Placement request " + reservation_uuid + " did not complete: " + statusRes)
    end
    
    return statusRes, host, datastore
  end

  ##
  # Requests a VMTurbo placement recommendation and returns the VMTurbo reservation request uuid.
  #
  def request_recommendation(reservation_name, vmPrefix, template_name, vmCount)
    log("debug", "Creating reservation: " + reservation_name + ", " +
        "vmPrefix: " + vmPrefix + ", " +
        "template_name: " + template_name + ", " +
        "count: " + vmCount.to_s)
    
    log("debug", "-- Get Template & Deployment Profile --")
    template_uuid, deployment_profile_uuid = self.get_template_uuid_and_deployment_profile_uuid(template_name)
    log("debug", "Template uuid for " + template_name + ": " + template_uuid)
    log("debug", "Deployment Profile uuid for " + template_name + ": " + deployment_profile_uuid)

    log("debug", "-- Create Reservation--")
    reservation_uuid = self.request_placement(reservation_name, vmPrefix, template_uuid, deployment_profile_uuid, vmCount)
    log("debug", "Reservation uuid: " + reservation_uuid)

    log("debug", "-- Poll and Get Resources --")
    status_res, host, datastore = self.poll_for_status(reservation_uuid)
    log("debug", "Status of reservation #{reservation_uuid}: " + status_res)
    log("debug", "Reservation resources for #{reservation_uuid}: Host: " + host + ", datastore: " + datastore)

    log("debug", "-- Delete --")
    deleted = self.delete_placement(reservation_uuid)
    log("debug", "Delete reservation " + reservation_uuid + " returned: " + deleted)

    return status_res, host, datastore
  end

end # class VMTurboScheduler 

#
# Instantiate a VMTScheduler and request a VM placement recommendation
#
vmt_sched = VMTurboScheduler.new($vmt_host, $vmt_username, $vmt_password)

VM_COUNT = 1                # MIQ handles larger requests as a series of individual requests
template_name = vm.name                                 # "SUSE64"         
vm_prefix = "MIQ-#{prov.get_option(:vm_name)}"          # "MIQ-vm-10"      # user-supplied name
reservation_name = "MIQ-Request-#{prov.miq_request_id}" # "MIQ-Request-10" # MIQ request ID

status_res, vmt_host_name, vmt_storage_name = vmt_sched.request_recommendation(reservation_name, vm_prefix, template_name, VM_COUNT)

$evm.log("info", LOG_PREFIX + "Reservation resources: Status: " + status_res + " Host: " + vmt_host_name + ", Datastore:" + vmt_storage_name)

#
# Find the MIQ Host and Datastore objects correpesonding to the VMTurbo recommendations
#
host = storage = nil

ems.hosts.each do |h|
  if vmt_host_name.casecmp(h.name) == 0
    host = h
    break
  end
end

$evm.log("info", LOG_PREFIX + "Host:<#{host.nil? ? "nil" : host.name}>")

if !host.nil?
  host.storages.each do |s|
    if vmt_storage_name.casecmp(s.name) == 0
      storage = s
      break
    end
  end
end

$evm.log("info", LOG_PREFIX + "Storage:<#{storage.nil? ? "nil" : storage.name}>")

#########################
# VMTurbo additions - end
#########################  

# Set host and storage
if host
  prov.set_host(host)
  # set folder if it is not set already
  set_folder(prov, host, vm) if prov.get_option(:placement_folder_name).nil?
end

prov.set_storage(storage) if storage

$evm.log("info", "vm=[#{vm.name}] host=[#{host}] storage=[#{storage}]")
